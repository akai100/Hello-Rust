# 闭包

Rust 的 闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数。

## 捕获环境

## 闭包类型推断和注解

## 捕获引用和移动所有权

捕获环境中的值的三种方式：

+ 不可变借用
  ```rust
  let list = vec![1, 2, 3];
  println!("Before defining closure: {list:?}");

  let only_borrows = || println!("From closure: {list:?}");    // 对 list 的不可变引用

  println!("Before calling closure: {list:?}");
  only_borrows();
  println!("After calling closure: {list:?}");
  ```
+ 可变借用
  ```rust
  let mut list = vec![1, 2, 3];
  println!("Before defining closure: {list:?}");

  let mut borrows_mutably = || list.push(7);    // 可变借用

  borrows_mutably();   // 可变借用：闭包定义和调用之前不能有不可变引用来打印
  println!("After calling closure: {list:?}");
  ```
+ 获取所有权
  希望强制闭包获取它在环境中所使用的值的所有，可以在参数列表前使用```move```关键字。
  ```rust
  let list = vec![1, 2, 3];
  println!("Before defining closure: {list:?}");

  thread::spawn(move || println!("From thread: {list:?}"))
      .join()
      .unwrap();
  ```
## 将捕获的值移出闭包和 Fn trait

1. ```FnOnce```
   
   适用于只能被调用一次的闭包。所有闭包至少都实现了这个 trait。一个会将捕获的值从闭包体中移出的闭包只会实现 ```FnOnce``` trait，

   使用场景：适用于一次性操作（如消费所有权的任务、线程间传递数据）。

3. ```FnMut```

   适用于不会将捕获的值移出闭包体，但可能会修改捕获值的闭包。这类闭包可以被调用多次。

   使用场景：适用于需要修改状态的场景（如累加器、迭代器适配器）

5. ```Fn```

   适用于既不将捕获的值移出闭包体，也不修改捕获值的闭包，同时也包括不从环境中捕获任何值的闭包。这类闭包可以被多次调用而不会改变其环境，这在会多次并发调用闭包的场景中十分重要。

   使用场景：适用于多次调用且只读场景（如缓存逻辑、回调函数），且通用且性能最优。

